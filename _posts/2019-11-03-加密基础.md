---
layout:	post
title:	加密基础知识
author: StoneLi
description: 加密基础知识
catalog: true
tags: [加密,对称加密,非对称加密,分组加密]
---


> 本文主要讲解加密的**基本定义**，以及**对称加密**中的**分组加密**

# 1. 加密算法分类

## 1.1 对称加密
  * 对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。

  * 优点：算法公开、计算量小、加密速度快、加密效率高。

  * 缺点：交易双方都使用同样钥匙，安全性得不到保证。此外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。而与公开密钥加密算法比起来，对称加密算法能够提供加密和认证却缺乏了签名功能，使得使用范围有所缩小。

  * 常用对称加密算法包括 DES、3DES、AES
    1. DES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。
    2. 3DES（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。
    3. AES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高，支持128、192、256、512位密钥的加密。

  > 对称加密通常使用的是相对较小的密钥，一般小于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用1 bit来做这个密钥，那黑客们可以先试着用0来解密，不行的话就再用1解；但如果你的密钥有1 MB大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。密钥的大小既要照顾到安全性，也要照顾到效率，是一个trade-off。

## 1.2 非对称加密
  * 非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人--银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。

  * 优点：安全性更高，公钥是公开的，秘钥是自己保存的，不需要将私钥给别人。

  * 缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。

  * 非对称加密算法包括 RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法），常见的有RSA、ECC。

  > 对称加密算法相比非对称加密算法来说，加解密的效率要高得多。但是缺陷在于对于秘钥的管理上，以及在非安全信道中通讯时，密钥交换的安全性不能保障。所以在实际的网络环境中，会将两者混合使用。

# 2. 对称加密分类

## 2.1 分组密码：也叫块加密(block cyphers)

  一次加密明文中的一个块。是将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算（加密运算的逆运算），还原成明文组。

### 2.1.1 块大小设置

  块的大小根据算法需求来决定。
  例如，AES 的数据块是128bits，也就是16B，所以，块的大小是16字节。
  例如，DES 的数据块是64bits，也就是8B，所以，块的大小是8字节。
  另外，填充模式一般针对的是块加密模式(分组加密模式)，MD5、SHA等散列方式没有填充模式。

### 2.1.2 填充（Padding）方式

  假设块长度为8字节，要加密的明文数据长度为9字节。那么消息被切成两个块，第二块只有1字节，需要填充7个字节。假定9字节的明文数据为：F1 F2 F3 F4 F5 F6 F7 F8 F9。

  * **Zero填充**：全部填充为0的字节，结果如下：
  ```
    F1 F2 F3 F4 F5 F6 F7 F8     //第一块
    F9 00 00 00 00 00 00 00     //第二块
  ```
  * **X923填充**：填充为0的字节序列，最后一个字节记录填充的总字节数，结果如下：
  ```
    F1 F2 F3 F4 F5 F6 F7 F8     //第一块
    F9 00 00 00 00 00 00 07     //第二块
  ```
  * **PKCS7/PKCS5填充**：每个填充的字节都记录了填充的总字节数，结果如下：
  ```
    F1 F2 F3 F4 F5 F6 F7 F8     //第一块
    F9 07 07 07 07 07 07 07     //第二块
  ```
  * **ISO10126填充**：填充字节可以是0x00，也可以是随机字节序列，最后一个字节记录填充的总字节数，结果如下：
  ```
    F1 F2 F3 F4 F5 F6 F7 F8     //第一块
    F9 EF F7 3A 7D 75 F6 07     //第二块
  ```

   > 填充时，**必须保证最后一块包含填充数据**，即如果数据长度刚好被块整分，那么最后添加一块全部为填充数据,否则无法知道最后一块的内容到底是数据还是填充内容。例如：明文长度为8字节，块长度也为8字节，使用Zero填充，那么填充数据应该是```F1 F2 F3 F4 F5 F6 F7 F8``` => ```F1 F2 F3 F4 F5 F6 F7 F8 + 00 00 00 00 00 00 00 00```。

### 2.1.3 分组密码的工作模式

#### ECB：Electronic Code Book，电子密码本模式
   * 最后一个明文分组必须要填充
     * des/3des -> 最后一个分组填充满8字节
     * aes -> 最后一个分组填充满16字节

   * 不需要初始化向量

   * 加密方式：一个明文分组加密成一个密文分组，每个明文分组可被独立地不按次序地进行加密。

   * 优点：简单，有利于并行计算，误差不会被传送。如果密文中数据位出错，解密时，就会使得相对应的整个明文分组解密错误，但不会影响其它明文。然而，如果密文中偶尔丢失或添加一些数据位，那么整个密文序列将不能正确解密，除非有某种帧结构能够重新排列分组的边界。

   * 缺点：不隐藏明文的模式；可能对明文进行主动攻击。如果密码分析者具有很多消息的明文和密文，那他就可以在不知道密钥的情况下编辑密码本。

   * 在许多实际情况中，消息格式趋于重复，不同的消息可能会有一些位序列是相同的，比如电子邮件就可能有固定的结构，而这些消息在很大程度上是冗余的或者有一个很长的0和空格组成的字符串。如果加密的消息具有一些冗余消息，那么这些信息趋向于在不同消息的同一位置出现，密码分析者就可以获得很多信息，可推断出使用了ECB加密，从而对明文发动攻击。加密消息块相互独立称为被攻击的弱点。

#### CBC：Cipher Block Chaining，密码分组链接模式
   * 最后一个明文分组需要填充
     * des/3des -> 最后一个分组填充满8字节
     * aes -> 最后一个分组填充满16字节

   * 需要一个初始化向量 - 一个数组
     * 数组的长度: 与明文分组相等
     * 数据来源: 负责加密的人的提供的
     * 加解密使用的初始化向量值必须相同

   * 加密方式：使用了初始化向量（IV）和第一组明文进行异或操作，然后加密，加密后的密文与下一组明文进行异或操作，以此类推。这种方式保证了每组密文依赖于它前面所有的明文。同时，为了保证每条消息的唯一性，在第一块中需要使用初始化向量。

   * 缺点：加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。解决后一个问题的一种方法是利用密文窃取。

   * 注意在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而在解密时，从两个邻近的密文块中即可得到一个明文块。因此，解密过程可以被并行化，而解密时，密文中一位的改变只会导致其对应的明文块和下一个明文块中对应位发生改变，不会影响到其它明文的内容。

#### CFB：Cipher FeedBack，密码反馈模式
   * 需要一个初始化向量 - 一个数组
     * 数组的长度: 与明文分组相等
     * 数据来源: 负责加密的人的提供的
     * 加解密使用的初始化向量值必须相同

   * 不需要填充

   * 加密方式：与CBC相比，初始化向量（IV）和明文颠倒了一下位置。因此与CBC不同，CFB不会先进行初始化向量和第一组明文的异或操作后进行加密，然后密文与下一组明文再进行异或后加密操作，而是它会首先对初始化向量进行加密，然后由加密后的初始化向量与明文进行异或操作生成密文，接着再对这个密文进行加密，然后与下一组明文进行异或操作。

   * 特点：密文没有规律, 明文分组是和一个数据流进行的按位异或操作, 最终生成了密文, 其自同步特性仅仅与CBC相同，即若密文的一整块发生错误，CBC和CFB都能解密大部分数据，而仅有一位数据错误。若需要在仅有了一位或一字节错误的情况下也让模式具有自同步性，必须每次只加密一位或一字节。可以将移位寄存器作为块密码的输入，以利用CFB的自同步性。

#### OFB：Output FeedBack，输出反馈模式
   * 需要一个初始化向量 - 一个数组
     * 数组的长度: 与明文分组相等
     * 数据来源: 负责加密的人的提供的
     * 加解密使用的初始化向量值必须相同
     
   * 不需要填充

   * 加密方式：与CFB非常相似。它们的不同在于加密后的初始化向量没有与明文进行异或操作。事实上对于第一组明文，初始化向量加密以后作为第二组明文的输入并且再与第一组明文进行异或操作。后续的加密操作都发生在异或之前。

   * 特点：密文没有规律, 明文分组是和一个数据流进行的按位异或操作, 最终生成了密文, 输出反馈模式可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码（比如奇偶校正位），即使在加密前计算而在加密后进行校验也可以得出正确结果。

#### CTR：CounTeR，计数器模式
   * 不需要初始化向量
     * go接口中的iv可以理解为随机数种子, iv的长度 == 明文分组的长度

   * 不需要填充

   * 特点：密文没有规律, 明文分组是和一个数据流进行的按位异或操作, 最终生成了密文, 与OFB相似，CTR将块密码变为流密码。它通过递增一个加密计数器以产生连续的密钥流，其中，计数器可以是任意保证不产生长时间重复输出的函数，但使用一个普通的计数器是最简单和最常见的做法。使用简单的、定义好的输入函数是有争议的：批评者认为它“有意的将密码系统暴露在已知的、系统的输入会造成不必要的风险”。目前，CTR已经被广泛的使用了，由输入函数造成的问题被认为是使用的块密码的缺陷，而非CTR模式本身的弱点。

   * CTR模式的特征类似于OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR适合运用于多处理器的硬件上。

## 2.2 序列密码：也叫流加密(stream cyphers)

一次加密明文中的一个位。是指利用少量的密钥（制乱元素）通过某种复杂的运算（密码算法）产生大量的伪随机位流，用于对明文位流的加密。解密是指用同样的密钥和密码算法及与加密相同的伪随机位流，用以还原明文位流。